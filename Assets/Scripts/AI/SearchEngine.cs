// --------------------------------------------------------------------------------------------------------------------
// <copyright file=SearchEngine.cs company=League of HTC Vive Dev>
/*
11111111111111111111111111111111111111001111111111111111111111111
11111111111111111111111111111111111100011111111111111111111111111
11111111111111111111111111111111100001111111111111111111111111111
11111111111111111111111111111110000111111111111111111111111111111
11111111111111111111111111111000000111111111111111111111111111111
11111111111111111111111111100000011110001100000000000000011111111
11111111111111111100000000000000000000000000000000011111111111111
11111111111111110111000000000000000000000000000011111111111111111
11111111111111111111111000000000000000000000000000000000111111111
11111111111111111110000000000000000000000000000000111111111111111
11111111111111111100011100000000000000000000000000000111111111111
11111111111111100000110000000000011000000000000000000011111111111
11111111111111000000000000000100111100000000000001100000111111111
11111111110000000000000000001110111110000000000000111000011111111
11111111000000000000000000011111111100000000000000011110001111111
11111110000000011111111111111111111100000000000000001111100111111
11111111000001111111111111111111110000000000000000001111111111111
11111111110111111111111111111100000000000000000000000111111111111
11111111111111110000000000000000000000000000000000000111111111111
11111111111111111100000000000000000000000000001100000111111111111
11111111111111000000000000000000000000000000111100000111111111111
11111111111000000000000000000000000000000001111110000111111111111
11111111100000000000000000000000000000001111111110000111111111111
11111110000000000000000000000000000000111111111110000111111111111
11111100000000000000000001110000001111111111111110001111111111111
11111000000000000000011111111111111111111111111110011111111111111
11110000000000000001111111111111111100111111111111111111111111111
11100000000000000011111111111111111111100001111111111111111111111
11100000000001000111111111111111111111111000001111111111111111111
11000000000001100111111111111111111111111110000000111111111111111
11000000000000111011111111111100011111000011100000001111111111111
11000000000000011111111111111111000111110000000000000011111111111
11000000000000000011111111111111000000000000000000000000111111111
11001000000000000000001111111110000000000000000000000000001111111
11100110000000000001111111110000000000000000111000000000000111111
11110110000000000000000000000000000000000111111111110000000011111
11111110000000000000000000000000000000001111111111111100000001111
11111110000010000000000000000001100000000111011111111110000001111
11111111000111110000000000000111110000000000111111111110110000111
11111110001111111100010000000001111100000111111111111111110000111
11111110001111111111111110000000111111100000000111111111111000111
11111111001111111111111111111000000111111111111111111111111100011
11111111101111111111111111111110000111111111111111111111111001111
11111111111111111111111111111110001111111111111111111111100111111
11111111111111111111111111111111001111111111111111111111001111111
11111111111111111111111111111111100111111111111111111111111111111
11111111111111111111111111111111110111111111111111111111111111111
*/
//   
// </copyright>
// <summary>
//  ChineseChessVR
// </summary>
// <author>胡良云（CloudHu）</author>
//中文注释：胡良云（CloudHu） 4/28/2017

// --------------------------------------------------------------------------------------------------------------------
using UnityEngine;

/// <summary>
/// FileName: SearchEngine.cs
/// Author: 胡良云（CloudHu）
/// Corporation: 
/// Description: 搜索算法基类
/// DateTime: 4/28/2017
/// </summary>
public class SearchEngine{

    #region Public Variables  //公共变量区域


    #endregion


    #region Protected Variables   //受保护变量区域
    protected byte[,] CurPosition = new byte[10, 9];  //搜索时用于当前节点棋盘状态的数组
    protected GlobalConst._chessMove m_cmBestMove;    //记录最佳走法的变量
    //protected ChessMoveGenerator m_pMG; //走法产生器类->静态方法
    protected ChessEvaluation m_pEval;  //棋子估值类
    protected int m_nSearchDepth;   //最大搜索深度
    protected int m_nMaxDepth;      //当前搜索的最大搜索深度
    #endregion


    #region MonoBehaviour CallBacks //回调函数区域
    #endregion

    #region Public Methods	//公共方法区域
    /// <summary>
    /// 为当前局面寻找一步好棋
    /// </summary>
    /// <param name="chessPosition">棋局</param>
    public virtual void SearchAGoodMove(byte[,] chessPosition) { }

    /// <summary>
    /// 设置最大搜索深度
    /// </summary>
    /// <param name="nDepth">深度</param>
    public void SetSearchDeepth(int nDepth)
    {
        m_nSearchDepth = nDepth;
    }

    /// <summary>
    /// 设置估值引擎
    /// </summary>
    /// <param name="pEval"></param>
    public void SetEvaluator(ChessEvaluation pEval)
    {
        m_pEval = pEval;
    }

    ~SearchEngine()
    {
        m_pEval = null;
    }
    #endregion

    #region Protected Method 
    /// <summary>
    /// 根据走法产生走之后的棋盘
    /// </summary>
    /// <param name="move">走法</param>
    /// <returns>棋子ID</returns>
    protected byte MakeMove(GlobalConst._chessMove move) {
        byte nChessID;
        nChessID = CurPosition[move.To.x, move.To.z];//取目标位置的棋子
        //把棋子移动到目标位置
        CurPosition[move.To.x, move.To.z] = CurPosition[move.From.x, move.From.z];
        //将原来的位置置空
        CurPosition[move.From.x, move.From.z] = GlobalConst.NOCHESS;
        //返回被吃掉的棋子
        return nChessID;
    }

    /// <summary>
    /// 恢复某一走法恢复棋盘
    /// </summary>
    /// <param name="move">走法</param>
    /// <param name="nChessID">棋子类型</param>
    protected void UnMakeMove(GlobalConst._chessMove move,byte nChessID)
    {
        //将目标位置的棋子移回原位
        CurPosition[move.From.x, move.From.z] = CurPosition[move.To.x, move.To.z];
        //恢复目标位置的原有棋子
        CurPosition[move.To.x, move.To.z] = nChessID;
    }

    /// <summary>
    /// 用于判断当前局面是否已经分出胜负
    /// </summary>
    /// <param name="chessPosition">棋局</param>
    /// <param name="nDepth">深度</param>
    /// <returns></returns>
    protected int IsGameOver(byte[,] chessPosition,int nDepth)
    {

        bool RedKingLive = true, BlackKingLive = true;
        //检查是否有将帅
        if (ChessmanManager.chessman[GlobalConst.R_KING]._dead)
        {
            RedKingLive = false;
        }
        if (ChessmanManager.chessman[GlobalConst.B_KING]._dead)
        {
            BlackKingLive = false;
        }
        int i = (m_nMaxDepth - nDepth + 1) % 2; //取当前奇偶标志
        if (!RedKingLive)   //红帅不在了
        {
            if (i==1)
            {
                return 19990 + nDepth;  //奇数层返回极大值
            }
            else
            {
                return -19990 - nDepth;  //偶数层返回极小值
            }
        }
        if (!BlackKingLive)   //黑将不在了
        {
            if (i == 0)
            {
                return 19990 + nDepth;  //偶数层返回极大值
            }
            else
            {
                return -19990 - nDepth;  //奇数层返回极小值
            }
        }
        return 0;   //将帅都在返回0
    }

    #endregion

}
