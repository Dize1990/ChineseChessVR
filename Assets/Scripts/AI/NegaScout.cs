// --------------------------------------------------------------------------------------------------------------------
// <copyright file=NegaScout.cs company=League of HTC Vive Dev>
/*
11111111111111111111111111111111111111001111111111111111111111111
11111111111111111111111111111111111100011111111111111111111111111
11111111111111111111111111111111100001111111111111111111111111111
11111111111111111111111111111110000111111111111111111111111111111
11111111111111111111111111111000000111111111111111111111111111111
11111111111111111111111111100000011110001100000000000000011111111
11111111111111111100000000000000000000000000000000011111111111111
11111111111111110111000000000000000000000000000011111111111111111
11111111111111111111111000000000000000000000000000000000111111111
11111111111111111110000000000000000000000000000000111111111111111
11111111111111111100011100000000000000000000000000000111111111111
11111111111111100000110000000000011000000000000000000011111111111
11111111111111000000000000000100111100000000000001100000111111111
11111111110000000000000000001110111110000000000000111000011111111
11111111000000000000000000011111111100000000000000011110001111111
11111110000000011111111111111111111100000000000000001111100111111
11111111000001111111111111111111110000000000000000001111111111111
11111111110111111111111111111100000000000000000000000111111111111
11111111111111110000000000000000000000000000000000000111111111111
11111111111111111100000000000000000000000000001100000111111111111
11111111111111000000000000000000000000000000111100000111111111111
11111111111000000000000000000000000000000001111110000111111111111
11111111100000000000000000000000000000001111111110000111111111111
11111110000000000000000000000000000000111111111110000111111111111
11111100000000000000000001110000001111111111111110001111111111111
11111000000000000000011111111111111111111111111110011111111111111
11110000000000000001111111111111111100111111111111111111111111111
11100000000000000011111111111111111111100001111111111111111111111
11100000000001000111111111111111111111111000001111111111111111111
11000000000001100111111111111111111111111110000000111111111111111
11000000000000111011111111111100011111000011100000001111111111111
11000000000000011111111111111111000111110000000000000011111111111
11000000000000000011111111111111000000000000000000000000111111111
11001000000000000000001111111110000000000000000000000000001111111
11100110000000000001111111110000000000000000111000000000000111111
11110110000000000000000000000000000000000111111111110000000011111
11111110000000000000000000000000000000001111111111111100000001111
11111110000010000000000000000001100000000111011111111110000001111
11111111000111110000000000000111110000000000111111111110110000111
11111110001111111100010000000001111100000111111111111111110000111
11111110001111111111111110000000111111100000000111111111111000111
11111111001111111111111111111000000111111111111111111111111100011
11111111101111111111111111111110000111111111111111111111111001111
11111111111111111111111111111110001111111111111111111111100111111
11111111111111111111111111111111001111111111111111111111001111111
11111111111111111111111111111111100111111111111111111111111111111
11111111111111111111111111111111110111111111111111111111111111111
*/
//   
// </copyright>
// <summary>
//  ChineseChessVR
// </summary>
// <author>胡良云（CloudHu）</author>
//中文注释：胡良云（CloudHu） 5/2/2017

// --------------------------------------------------------------------------------------------------------------------
/// <summary>
/// FileName: NegaScout.cs
/// Author: 胡良云（CloudHu）
/// Corporation: 
/// Description: 极小窗口搜索
/// DateTime: 5/2/2017
/// </summary>
public class NegaScout : SearchEngine {

    #region Public Variables  //公共变量区域


    #endregion


    #region Private Variables   //私有变量区域


    #endregion


    #region MonoBehaviour CallBacks //回调函数区域
    #endregion

    #region Public Methods	//公共方法区域

    public override void SearchAGoodMove(byte[,] chessPosition)
    {
        CurPosition = chessPosition;    //把当前局面赋值给CurPosition
        m_nMaxDepth = m_nSearchDepth;   //设置搜索深度
        PrincipalVariation(m_nMaxDepth, -20000, 20000);    //搜索算法
        //将棋盘修改为走过的
        int killId = CurPosition[m_cmBestMove.To.z, m_cmBestMove.To.x];//取目标位置的棋子
        NetworkTurn.Instance.MovingChessman(m_cmBestMove.ChessId, killId, m_cmBestMove.To.z, m_cmBestMove.To.x);
    }

    public int PrincipalVariation(int depth,int alpha,int beta)
    {
        int curScore, possibleMoveCount, bestScore;
        byte chessType;
        //检查是否游戏结束
        int max = IsGameOver(CurPosition, depth);   //获取极值
        if (max!=0)
        {
            return max; //胜负已分则返回极值
        }
        if (depth<=0)   //叶子节点取估值
        {
            return m_pEval.Evaluate(CurPosition, (m_nMaxDepth - depth) % 2);
        }
        //列举出当前局面下一步所有可能的走法
        possibleMoveCount = ChessMoveGenerator.CreatePossibleMove(CurPosition, depth, (m_nMaxDepth - depth) % 2);
        //根据走法产生第一个节点
        chessType = MakeMove(ChessMoveGenerator.m_MoveList[depth, 0]);
        //使用全窗口搜索第一个节点
        bestScore = -PrincipalVariation(depth - 1, -beta, -alpha);
        //撤销第一个节点
        UnMakeMove(ChessMoveGenerator.m_MoveList[depth, 0], chessType);
        if (depth==m_nMaxDepth)
        {   //在根部保存最佳方法
            m_cmBestMove = ChessMoveGenerator.m_MoveList[depth, max];
        }
        for (max = 1; max < possibleMoveCount; max++) //从第二个节点开始遍历所有可能的走法
        {
            if (bestScore<beta) //如果不能beta剪枝
            {
                if (bestScore>alpha)
                {
                    alpha = bestScore;
                }
                //根据走法产生新局面
                chessType = MakeMove(ChessMoveGenerator.m_MoveList[depth, max]);
                //递归调用搜索下一层的节点
                curScore = -PrincipalVariation(depth - 1, -alpha - 1, -alpha);
                if (curScore>alpha && curScore<beta)
                {
                    //fail high,高于期望值,重新搜索
                    bestScore = -PrincipalVariation(depth - 1, -alpha - 1, -alpha);
                    if (depth == m_nMaxDepth)
                    {   //在根部保存最佳方法
                        m_cmBestMove = ChessMoveGenerator.m_MoveList[depth, max];
                    }
                }
                else if (curScore>bestScore)
                {
                    bestScore = curScore;   //窄窗口搜索命中
                    if (depth == m_nMaxDepth)
                    {   //在根部保存最佳方法
                        m_cmBestMove = ChessMoveGenerator.m_MoveList[depth, max];
                    }
                }
                //撤销子节点
                UnMakeMove(ChessMoveGenerator.m_MoveList[depth, max], chessType);
            }
        }
        return bestScore;    //返回极大值或边界值
    }
	#endregion
	
}
